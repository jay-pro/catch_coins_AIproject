# -*- coding: utf-8 -*-"""Simple game where the self.player has to dodge the asteroids (grey) and catch thegolden coins (yellow)The code was changed to make it similar to a OpenAI gym environment@author: Riccardo Rossi"""import pygameimport numpy as npMULTIPLIER = 1screen_WIDTH = 84 * MULTIPLIERscreen_HEIGHT = screen_WIDTH# HyperparametersACTION_STEPS = 4   # Steps to observe before deciding next actionPLAYER_SPEED = MULTIPLIERGOLD_SPEED = MULTIPLIEROBSTACLE_SPEED = MULTIPLIERREWARD_CATCHING_GOLD = 1.PROB_OBJECT_SPAWNED = 0.12# Probability gold is spawned conditional to an object being spawnedPROB_GOLD_SPAWNED = 0.8GAME_TITLE = 'Asteroids - dodge the asteroids (grey), catch the gold (yellow)'TPS = 100             FRAME_WIDTH = MULTIPLIERFRAME_FROM_BORDER = MULTIPLIER# Loose definition of a colours used in the gameBLACK = (  0,   0,   0)WHITE = (255, 255, 255)RED =   (165,  42,  42)GOLD =  (255, 215,  64)GREY =  (112, 138, 127)class Block(pygame.sprite.Sprite):    def __init__(self, width, height):        pygame.sprite.Sprite.__init__(self)        self.image = pygame.Surface([width, height])        self.rect = self.image.get_rect()class Player(Block):    def __init__(self, colour=RED, width=5*MULTIPLIER, height=3*MULTIPLIER):        Block.__init__(self, width, height)        self.image.fill(colour)        self.rect.x = int((screen_WIDTH/2 - width) / MULTIPLIER)*MULTIPLIER        self.rect.y = screen_HEIGHT - height - 3*MULTIPLIER        self.score = 0        self.speed = [+PLAYER_SPEED, 0]    def is_position_allowed(self):        if (self.rect.right > screen_WIDTH - FRAME_FROM_BORDER - FRAME_WIDTH or             self.rect.x < FRAME_FROM_BORDER + FRAME_WIDTH):            return(False)        if (self.rect.bottom > screen_HEIGHT - FRAME_FROM_BORDER - FRAME_WIDTH             or self.rect.y < FRAME_FROM_BORDER + FRAME_WIDTH):            return(False)        return(True)    def move(self):        self.rect.x += self.speed[0]        self.rect.y += self.speed[1]    def update(self):        self.move()class Asteroid(Block):    def __init__(self, colour=GREY, width=2*MULTIPLIER, height=2*MULTIPLIER, speed=OBSTACLE_SPEED):        Block.__init__(self, width, height)        self.image.fill(colour)        self.rect.x = int(np.random.randint(            FRAME_FROM_BORDER + FRAME_WIDTH,             screen_WIDTH - FRAME_FROM_BORDER - FRAME_WIDTH - width)/MULTIPLIER)*MULTIPLIER        self.rect.y = FRAME_FROM_BORDER + FRAME_WIDTH        self.speed = speed        def update(self):        self.rect.y += self.speed        class Gold(Block):    def __init__(self, colour=GOLD, width=2*MULTIPLIER, height=2*MULTIPLIER, speed=GOLD_SPEED):        Block.__init__(self, width, height)        self.image.fill(colour)        self.rect.x = int(np.random.randint(            FRAME_FROM_BORDER + FRAME_WIDTH,             screen_WIDTH - FRAME_FROM_BORDER - FRAME_WIDTH - width)/MULTIPLIER)*MULTIPLIER        self.rect.y = FRAME_FROM_BORDER + FRAME_WIDTH        self.speed = speed    def update(self):        self.rect.y += self.speedclass Game():    def __init__(self):        pygame.init()        pygame.display.set_caption(GAME_TITLE)        self.screen = pygame.display.set_mode([screen_WIDTH, screen_HEIGHT])        self.MULTIPLIER = MULTIPLIER                self.all_items_list = pygame.sprite.Group()        self.player_list = pygame.sprite.Group()        self.obstacle_list = pygame.sprite.Group()        self.gold_list = pygame.sprite.Group()                self.reset()                    def reset(self):                self.all_items_list.empty()        self.player_list.empty()        self.obstacle_list.empty()        self.gold_list.empty()                self.player = Player()        self.player_list.add(self.player)        self.all_items_list.add(self.player)                self.screen.fill(BLACK)        image = pygame.surfarray.array3d(self.screen)        image = image[:, :, :]        return (image)               def step(self, action):                reward = 0.0        self.player.speed = [+PLAYER_SPEED * (action - 1), 0]                # Update all items' positions and the game_count            self.all_items_list.update()         # Create the background, basic frame, and score line        self.screen.fill(BLACK)        frame = pygame.draw.rect(self.screen, WHITE, pygame.Rect(                    (FRAME_FROM_BORDER, FRAME_FROM_BORDER),                    (screen_WIDTH - 2*FRAME_FROM_BORDER,                      screen_HEIGHT - 2*FRAME_FROM_BORDER)),                      FRAME_WIDTH)            # Generate obstacles and golden coins randomly        if ((not self.obstacle_list and not self.gold_list) or            np.random.uniform() < PROB_OBJECT_SPAWNED):                if np.random.uniform() < PROB_GOLD_SPAWNED:                gold = Gold()                self.gold_list.add(gold)                self.all_items_list.add(gold)            else:                asteroid = Asteroid()                self.obstacle_list.add(asteroid)                self.all_items_list.add(asteroid)            # Count the elements caught by the self.player         obstacle_hits = pygame.sprite.spritecollide(self.player,                                                     self.obstacle_list,                                                     True)        gold_hits = pygame.sprite.spritecollide(self.player,                                                 self.gold_list,                                                 True)            # If gold was caught by the self.player, then reward is distributed        if gold_hits:            reward = REWARD_CATCHING_GOLD * len(gold_hits)            self.player.score += reward            # Remove all elements that hit the bottom frame        for elem in list(self.obstacle_list) + list(self.gold_list):            if elem.rect.bottom > screen_HEIGHT - FRAME_FROM_BORDER:                elem.kill()                # Print all objects in the self.screen        self.all_items_list.draw(self.screen)        pygame.display.flip()            image = pygame.surfarray.array3d(self.screen)        image = image[:, :, :]                        kill = False        for event in pygame.event.get():             if event.type == pygame.QUIT:                kill = True                        if kill:             terminal = True        else:            terminal = obstacle_hits or not self.player.is_position_allowed()                    return (image,                reward,                terminal,                kill)            def close(self):        pygame.display.quit()        pygame.quit()        